/*
 * Syntatic.hh
 *
 *  Created on: Feb 25, 2017
 *      Author: eshinig
 */
#include <iostream>
#include <map>
#include <list>
#include <queue>
#include <stack>
#include <vector>
#include <algorithm>
#include <fstream>
#include "LexicalAnalyzer.hh"
#ifndef SRC_SYNTATIC_HH_
#define SRC_SYNTATIC_HH_

class Parser
{
public:
    Parser(){}
    Parser(std::list<TokenDS>);
    std::list<TokenDS> tokenListFromLexicalAnalyser;//TODO make this a pointer
    /*
     * This algorithm is based on Table driven design parser
     */
    void tableDrivenParserAlgorithm();
    std::list <std::string> derivation;
    std::list <std::string> inverseDerivation; //stack
    /*
     * Checks if the symbol is termical
     */
    bool isTerminal(std::string& x);


    const int ERROR_CODE = 87;//above 86 is an error
    std::vector<std::string> terminalSymbols = {"class","id","{","}",";","(",")","program","for","if","then","else","get","put","return","+","-","num","not",".","[","]",
            "integer","float","int",",","=","<","<=","<>","==",">",">=","or","*","/","and","$"};
    std::map  <std::string,int> terminalSymbolsMap =
    {
            // {0,"class","id","{","}",";","(",")","program","for","+","-","[","]","integer","float","int",",","=","<","<=","<>","==",">",">=","or","*","/","and","$"},
            {"class", 1},
            {"id", 2},
            {"{", 3},
            {"}", 4},
            {";", 5},
            {"(", 6},
            {")", 7},
            {"program", 8},
            {"for", 9},
            {"if", 10},
            {"then", 11},
            {"else", 12},
            {"get", 13},
            {"put", 14},
            {"return", 15},
            {"+", 16},
            {"-", 17},
            {"num", 18},
            {"not", 19},
            {".", 20},
            {"[", 21},
            {"]", 22},
            {"integer", 23},
            {"float", 24},
            {"int", 25},
            {",", 26},
            {"=", 27},
            {"<", 28},
            {"<=", 29},
            {"<>", 30},
            {"==", 31},
            {">", 32},
            {">=", 33},
            {"or", 34},
            {"*", 35},
            {"/", 36},
            {"and", 37},
            {"$", 38},
    };
    std::map  <std::string,int> nonTerminalSymbolsMap =
    {
            {"prog",1},
            {"N_classDecl",2},
            {"classDecl",3},
            {"RvarDeclfuncDef",4},
            {"varDeclfuncDef",5},
            {"varDeclNoTypeIDorfuncDefNoTypeID",6},
            {"varDeclNoTypeID",7},
            {"funcDefNoTypeID",8},
            {"N_varDecl",9},
            {"N_funcDef",10},
            {"progBody",11},
            {"funcHead",12},
            {"funcDef",13},
            {"funcBody",14},
            {"N_statement",15},
            {"varDecl",16},
            {"N_arraySize",17},
            {"statement",18},
            {"assignStat",19},
            {"statBlock",20},
            {"expr",21},
            {"COMM",22},
            {"relExpr",23},
            {"arithExpr",24},
            {"arithExprLR",25},
            {"sign",26},
            {"term",27},
            {"termLR",28},
            {"factor",29},
            {"variable",30},
            {"N_idnest_Prime",31},
            {"N_idnest",32},
            {"N_indice",33},
            {"idnest",34},
            {"indice",35},
            {"arraySize",36},
            {"type",37},
            {"fParams",38},
            {"N_fParamsTail",39},
            {"aParams",40},
            {"N_aParamsTail",41},
            {"fParamsTail",42},
            {"aParamsTail",43},
            {"assignOp",44},
            {"relOp",45},
            {"addOp",46},
            {"multiOp",47},
    };

    int parseTable[48][39] =
    {
          //{0,"class","id","{","}",";","(",")","program","for","if","then","else","get","put","return","+","-","num","not",".","[","]","integer","float","int",",","=","<","<=","<>","==",">",">=","or","*","/","and","$"},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
            {0,1,88,88,88,88,88,88,1,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,87},
            {0,2,88,88,88,88,88,88,3,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,4,88,88,88,88,88,88,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,5,88,6,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,5,5,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,7,88,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,7,7,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,87,88,87,8,9,88,88,88,88,88,88,88,88,88,88,88,88,88,88,8,88,88,87,87,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,87,88,87,10,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,10,88,88,87,87,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,87,88,87,88,11,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,87,87,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,13,88,13,88,88,88,88,13,13,88,88,13,13,13,88,88,88,88,88,88,88,88,12,12,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,14,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,14,14,88,88,88,88,88,88,88,88,88,88,88,88,15},
            {0,88,88,88,88,88,88,88,16,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,87},
            {0,88,17,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,17,17,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,18,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,18,18,88,88,88,88,88,88,88,88,88,88,88,88,87},
            {0,88,88,19,88,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,20,88,21,88,88,88,88,20,20,88,88,20,20,20,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,22,88,88,88,88,88,88,87,87,88,88,87,87,87,88,88,88,88,88,88,88,88,22,22,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,88,88,88,24,88,24,88,88,88,88,88,88,88,88,88,88,88,88,88,23,88,88,88,88,24,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,30,88,87,87,88,88,88,25,26,88,87,27,28,29,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,31,88,88,87,88,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,33,32,88,34,88,88,88,33,33,88,34,33,33,33,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,35,88,88,87,35,87,88,88,88,88,88,88,88,88,35,35,35,35,88,88,88,88,88,88,87,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,88,88,88,37,88,37,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,37,88,36,36,36,36,36,36,88,88,88,88,88},
            {0,88,38,88,88,87,38,88,88,88,88,88,88,88,88,88,38,38,38,38,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,39,88,88,87,39,87,88,88,88,88,88,88,88,88,39,39,39,39,88,88,87,88,88,88,87,88,87,87,87,87,87,87,88,88,88,88,88},
            {0,88,88,88,88,41,88,41,88,88,88,88,88,88,88,88,40,40,88,88,88,88,41,88,88,88,41,88,41,41,41,41,41,41,40,88,88,88,88},
            {0,88,87,88,88,88,87,88,88,88,88,88,88,88,88,88,42,43,87,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,44,88,88,87,44,87,88,88,88,88,88,88,88,88,44,44,44,44,88,88,87,88,88,88,87,88,87,87,87,87,87,87,87,88,88,88,88},
            {0,88,88,88,88,46,88,46,88,88,88,88,88,88,88,88,46,46,88,88,88,88,46,88,88,88,46,88,46,46,46,46,46,46,46,45,45,45,88},
            {0,88,48,88,88,87,47,87,88,88,88,88,88,88,88,88,51,51,49,50,88,88,87,88,88,88,87,88,87,87,87,87,87,87,87,87,87,87,88},
            {0,88,52,88,88,88,88,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,87,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,88,88,88,87,53,87,88,88,88,88,88,88,88,88,87,87,88,88,88,54,87,88,88,88,87,87,87,87,87,87,87,87,87,87,87,87,88},
            {0,88,55,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,57,88,88,57,88,57,88,88,88,88,88,88,88,88,57,57,88,88,57,56,57,88,88,88,57,57,57,57,57,57,57,57,57,57,57,57,88},
            {0,88,58,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,87,59,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,88,88,88,87,88,87,88,88,88,88,88,88,88,88,88,88,88,88,88,60,88,88,88,88,87,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,62,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,61,63,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,64,88,88,88,88,65,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,64,64,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,88,88,88,88,88,67,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,66,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,68,88,88,88,68,69,88,88,88,88,88,88,88,88,68,68,68,68,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,88,88,88,88,88,71,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,70,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,88,88,88,88,88,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,72,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,88,88,88,88,88,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,73,88,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,87,88,88,88,87,88,88,88,88,88,88,88,88,88,87,87,87,87,88,88,88,88,88,88,88,74,88,88,88,88,88,88,88,88,88,88,88},
            {0,88,87,88,88,88,87,88,88,88,88,88,88,88,88,88,87,87,87,87,88,88,88,88,88,88,88,88,75,76,77,78,79,80,88,88,88,88,88},
            {0,88,87,88,88,88,87,88,88,88,88,88,88,88,88,88,81,82,87,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,83,88,88,88,88},
            {0,88,87,88,88,88,87,88,88,88,88,88,88,88,88,88,87,87,87,87,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,84,85,86,88}} ;
    std::map<int,std::list<std::string> > productions =
    {
            {1,  {"N_classDecl","progBody"}},        //prog → N_classDecl
            {2, {"classDecl","N_classDecl"}},         //Ep
            {3, {"EPSILON"}},    //Ep
            {4,  {"class", "id","{" ,"RvarDeclfuncDef", "}" ,";"}},        //T
            {5, {"varDeclfuncDef","RvarDeclfuncDef"}},         //Tp
            {6, {"EPSILON"}},    //Tp
            {7,  {"type", "id", "varDeclNoTypeIDorfuncDefNoTypeID"}},    //F
            {8,  {"varDeclNoTypeID"}},              //F
            {9,  {"funcDefNoTypeID"}},              //F
            {10,  {"N_arraySize" ,";"}},        //E
            {11, {"(","fparam",")","funcBody",";"}},         //Ep
            {12, {"varDecl", "N_varDecl"}},    //Ep
            {13,  {"EPSILON"}},        //T
            {14,  {"funcDef", "N_funcDef"}},        //T
            {15, {"EPSILON"}},         //Tp
            {16, {"program", "funcBody", ";", "N_funcDef"}},    //Tp
            {17,  {"type", "id", "(", "fParams",")"}},    //F
            {18,  {"funcHead","funcBody",";"}},              //F
            {19,  {"{", "N_varDecl", "N_statement", "}"}},
            {20,  {"statement", "N_statement"}},              //F
            {21,  {"EPSILON"}},              //F
            {22,  {"type", "id", "N_arraySize", ";"}},        //E
            {23, {"arraySize", "N_arraySize"}},         //Ep
            {24, {"EPSILON"}},         //Ep
            {25, {"for", "(", "type","id", "assignOp", "expr", ";" , "relExpr", ";", "assignStat", ")" ,"statBlock" ,";"}},    //Ep
            {26, {"if", "(", "expr",")", "then", "statBlock", "else" , "statBlock",";"}},    //Ep
            {27,  {"get", "(", "variable", ")" ,";"}},        //T
            {28,  {"put", "(", "expr", ")" ,";"}},        //T
            {29,  {"return", "(", "expr", ")" ,";"}},        //T
            {30,  {"assignStat", ";"}},
            {31,  {"variable", "assignOp" ,"expr"}},        //T//T
            {32,  {"{","N_statement","}"}},        //T
            {33,  {"statement"}},    //Tp
            {34,  {"EPSILON"}},              //F
            {35,  {"arithExpr", "COMM"}},    //F
            {36,  {"relOp", "arithExpr"}},    //F
            {37,  {"EPSILON"}},              //F
            {38,  {"arithExpr", "relOp", "arithExpr"}},              //F
            {39,  {"term", "arithExprLR"}},        //E
            {40,  {"addOp", "term", "arithExprLR"}},//Ep
            {41,  {"EPSILON"}},
            {42, {"+"}},    //Ep
            {43,  {"-"}},        //T
            {44, {"factor", "termLR"}},         //Tp
            {45, {"multiOp", "factor", "termLR"}},    //Tp
            {46,  {"EPSILON"}},
            {47,  {"(", "arithExpr", ")"}},    //F
            {48,  {"N_idnest", "id", "N_indice_Prime"}},    //F
            {49,  {"num"}},
            {50,  {"not", "factor"}},//F
            {51,  {"sign", "factor"}},//F
            {52,  {"N_idnest", "id", "N_indice_Prime"}},    //F
            {53,  {"(","aParams",")"}},
            {54,  {"N_indice"}},              //F
            {55,  {"idnest" }},        //E
            {56,  {"indice","N_indice", "."}},
            {57,  {"EPSILON"}},        //T//E
            {58, {"id","N_indice"}},         //Ep
            {59, { "[", "arithExpr", "]"}},         //Tp
            {60, {"[", "integer", "]"}},    //Tp
            {61,  {"float"}},    //F
            {62,  {"id"}},              //F
            {63,  {"int"}},              //
            {64,  {"type", "id", "N_arraySize", "N_fParamsTail"}},        //EF
            {65,  {"EPSILON"}},        //T
            {66,  {"fParamsTail", "N_fParamsTail"}},        //EF
            {67,  {"EPSILON"}},        //T
            {68,  {"expr" ,"N_aParamsTail"}},        //E
            {69, {"EPSILON"}},         //Ep
            {70, {"aParamsTail", "N_aParamsTail"}},    //Ep
            {71,  {"EPSILON"}},        //T
            {72,  {",", "type","id", "N_arraySize"}},        //T
            {73, {",", "expr"}},         //Tp
            {74, {"="}},    //Tp
            {75,  {"<"}},    //F
            {76,  {"<="}},              //F
            {77,  {"<>"}},              //F
            {78,  {"=="}},        //E
            {79, {">"}},         //Ep
            {80, {">="}},    //Ep
            {81,  {"+"}},        //T
            {82, {"-"}},         //Tp
            {83, {"or"}},    //Tp
            {84,  {"*"}},    //F
            {85,  {"/"}},              //F
            {86,  {"and"}},              //F
    };

    //Implemented as Queue class id { int id [ integer ] ; int id [ integer ] ; } ;
    std::list <std::string> input = {"class","id","{","int","id","[", "integer","]",";","}",";",
            "program", "{", "int", "id", "[", "integer", "]", ";",
            "float", "id", "[", "integer", "]", ";", "}" ,";",
            "float", "id","(","int", "id", "[", "integer", "]", ")",
            "{", "float", "id", ";", "return", "(", "num" ,"*", "num", ")", ";", "}", ";","$"};

private:
    void printDerivation();
    void printInverseDerivation();
    void parseTerminalSymbol(const std::string& nonTerminal, std::string& token);
    /*
     * Reads next token from Lexical analyzer list
     */
    void buildInputFromLex();
    int currentTokenIndex;
};
#endif /* SRC_SYNTATIC_HH_ */
